<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <title>主页</title>
        <link rel="stylesheet" href="/theme/css/main.css" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
<a href="https://github.com/ancewer">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" />
</a>
        <header id="banner" class="body">
                <h1><a href="/">ancewer' blog </a></h1>
                <nav><ul>
                    <li><a href="/category/c.html">C++</a></li>
                    <li class="active"><a href="/category/csharp.html">Csharp</a></li>
                    <li><a href="/category/misc.html">misc</a></li>
                    <li><a href="/category/python.html">Python</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/MainPage1.html" rel="bookmark"
           title="Permalink to 主页">主页</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-05-21T22:20:00+08:00">
                Published: 2017-05-21
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/liu-chunbo.html">Liu Chunbo</a>
        </address>
<p>In <a href="/category/csharp.html">Csharp</a>.</p>
<p>tags: <a href="/tag/python.html">python</a> <a href="/tag/pelican.html">pelican</a> </p>
</footer><!-- /.post-info -->      <h1>Title</h1>
<p>C# wpf</p>
<p>1.Grid
在grid属性里面有rowdefinition和columndefinition可以把grid划分为多个grid子空间</p>
<p>2.&lt;&gt;
在xaml中这两个符号是关键字，需要显示时候可以用&amp;lt代替&lt;,用&amp;gt代替&gt;</p>
<p>3.xaml注意事项
在xaml文本中，如果想保留文本中原始空格，可以加入xml:space=”preserve”
xaml空间代码必须为闭合的，可以有两种闭合方式
<Button/> 和 <Button></Button>
控件的每个属性都可以分开写，比如
<Button Content=”内容”/>   //适合简单属性写法
或者
<Button><Button.Content>内容（可以是图片，其它控件，强大吧；但是貌似只能同时显示一种，但是可以使用stackpanel来包含所有内容）</Button.Content></Button> <br>
//适合复杂属性</p>
<p>4.List泛型
            List<int> list = new List<int>(); <br>
            list.Add(5);        //添加元素
            list.Add(153);
            list.Add(15);
            foreach(int i in list)
            {
                MessageBox.Show(i.ToString());
            }
list.Remove(5);//删除一个元素
list.Clear();//清空列表
list.Count();//数据个数</p>
<p>string类型(当然也可以是任何其他类型)
List<string> list1 = new List<string>();</p>
<p>5.通用属性及控件
Visibility  可见性
Foregroung  前景色
Background  背景色
FontSize        字体大小
IsEnabled   控件是否可用 bool型</p>
<p>TextBox：
IsReadOnly  是否只读
MaxLength   文本能输入的最大长度（只要是敲键盘最多输入的字符数，通过代码赋值时候不受此限制）
TextWrapping        是否自动换行  Wrap自动换行 NoWrap不自动换行</p>
<p>PasswordBox：
Password属性为密码</p>
<p>CheckBox：
IsChecked：是否选中，bool</p>
<p>RadioButton：
单选框，同组只能选中一个，所以如果有多种，要进行分组，在button的xaml属性中属于同组的添加GroupName=“组名”；</p>
<p>DatePicker：
//因为可能不选择任何类型，所以Selecteddate是可空的；
            DateTime? value = DatePicker1.SelectedDate;
            if(value==null)
            {
                MessageBox.Show("你没有选择");
            }
            else
            {MessageBox.Show(value.ToString());
}
MessageBox.Show(DateTime.Now.ToString());//只包含年月日
MessageBox.Show(DateTime.Today.ToString());//年月日小时分秒等</p>
<p>Image:      类似于winform中的PictureBox</p>
<p>ProgressBar：
进度条：IsIndeterminate是否不确定模式；
Maximum最大值；MiniMum最小值；
IsIndeterminate="True"      不确定值，反正忙着呢 </p>
<p>页面布局：
基本布局：Stackpanel Grid
<StackPanel>子控件</StackPanel> 默认纵向排列，添加Orientation="Horizontal"可改为横向</p>
<p>Menu：
菜单
    <Grid>
        <DockPanel >
        <Menu DockPanel.Dock="Top">
            <MenuItem Header="文件">
                <MenuItem Header="新建">
                    <MenuItem Header="txt"></MenuItem>
                    <MenuItem Header="mac"></MenuItem>
                </MenuItem>
                <MenuItem Header="打开"></MenuItem>
                <MenuItem Header="保存"></MenuItem>
            </MenuItem>
            <MenuItem Header="编辑"></MenuItem>
            <MenuItem Header="视图"></MenuItem></p>
<div class="highlight"><pre><span></span>    <span class="nt">&lt;/Menu&gt;</span>
        <span class="nt">&lt;ToolBar</span> <span class="na">DockPanel.Dock=</span><span class="s">&quot;Top&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Button</span> <span class="na">Content=</span><span class="s">&quot;保存&quot;</span><span class="nt">&gt;&lt;/Button&gt;</span>
            <span class="nt">&lt;Button</span> <span class="na">Content=</span><span class="s">&quot;新建&quot;</span><span class="nt">&gt;&lt;/Button&gt;</span>
            <span class="nt">&lt;Button</span> <span class="na">Content=</span><span class="s">&quot;自动保存&quot;</span><span class="nt">&gt;&lt;/Button&gt;</span>
        <span class="nt">&lt;/ToolBar&gt;</span>
        <span class="nt">&lt;TextBox</span> <span class="na">DockPanel.Dock=</span><span class="s">&quot;Bottom&quot;</span><span class="nt">&gt;&lt;/TextBox&gt;</span>
    <span class="nt">&lt;/DockPanel&gt;</span>


<span class="nt">&lt;/Grid&gt;</span>
</pre></div>


<p>ToolBar：
工具栏</p>
<p>Border：
StackPanel：
CornerRadius //边框倒角
 <Border BorderBrush="Silver" BorderThickness="5" Padding="10" CornerRadius="50">
        <StackPanel>
        <Label Foreground="Red"> 10</Label>
        <Button HorizontalAlignment="Center">10</Button>
        <Button Margin="20">10</Button>
        <Button MaxWidth="50">10</Button>
        <Button Margin="30">10</Button></p>
<div class="highlight"><pre><span></span><span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Border&gt;</span>
</pre></div>


<p>inkcancas:
属性
EditingMode="GestureOnly" 不保留笔画</p>
<p>6.可空数据类型（了解）
可空(null)数据类型：引用类型，自定义类，，string，等大部分类
不可控数据类型:值类型，int、boolean、decimal、DateTime等
string st = null;//不会出错
int i = null;       //出错
int? j = null;  //正确，数据库中的int可以为null，微软为了统一，就这样定义了可以null的int，可以把int赋值为int？，但不能把int？赋值给int。以下同理
DateTime t = null;  //错误
DateTime? t1 = null; //正确
如果需要把int？赋值给int，可以加上类型转换
int? i7 = 5;
int i8 = (int)i7;</p>
<p>7.理解路由事件
不太理解
1.直接路由事件
直接引发
2.冒泡路由事件
从事件最内部引发，一直到顶部
3.隧道路由事件
由上向下传递   Preview开头的事件</p>
<p>8.键盘事件
PreviewKeyDown 隧道路由
KeyDown 冒泡路由
PreviewTextInput 隧道路由，文本输入时候发生
TextInput 冒泡路由
PreviewKewUp 隧道路由，释放按键时发生
KeyUp   冒泡路由</p>
<p>9.鼠标事件
MouseEnter  鼠标进入
MouseLeave  鼠标离开，都是直接路由</p>
<p>PreviewMouseMove  <br>
MouseMove   鼠标移动</p>
<p>鼠标按下或离开
PreviewMouseLeftButtonDown
PreviewMouseRightButtonDown
MouseLeftButtonDown 冒泡路由
MouseRightButtonDown
PreviewMouseLeftButtonUp
PreviewMouseRightButtonUp
MouseLeftButtonUp       冒泡路由
MouseRightButtonUp</p>
<p>鼠标拖放</p>
<p>10.控件类
控件类
背景画刷和前景画刷
Background="LightBlue" 
Foreground="BlueViolet" 
字体
FontFamily="楷体,宋体,黑体"   前一个没找到会自动使用后面的
FontStyle="Italic" 
FontSize="50"
FontWeight="Black"  加粗样式
FontStretch="Expanded"      字体拉伸
鼠标光标
//设置鼠标光标
this.Cursor = Cursors.Wait;
或者在xaml控件中使用cursor属性</p>
<p>内容控件：
content属性
对其内容
标签
按钮
工具提示</p>
<p>TextBox：
VerticalScrollBarVisibility="Visible" 滚动条，默认不显示
TextWrapping="Wrap" 文本折叠，默认不自动换行
SelectionStart      鼠标在文本框中位置
SelecttionLength        选中长度
SelectedText            选中的文本
SpellCheck.IsEnabled="True" 拼写检查，单词有问题时出现下划线，可以右键忽略或改正，目前只能对英语、西班牙语、德语、法语
方法：
LineDown()   向下一行
PageDown()  向下一页</p>
<p>PasswordBox：
PasswordChar="8"        自定义掩码
ListBox：
列表框，内容可以很丰富
显式创建：
            <ListBox Margin="10" Name="listbox1">
                <!--<ListBoxItem BorderBrush="Red">
                    <Image Width="20" Source="images/06.jpg"></Image>
                </ListBoxItem>
                <ListBoxItem>蓝色</ListBoxItem>
                <ListBoxItem BorderBrush="Silver">黄色</ListBoxItem>
                <ListBoxItem>绿色</ListBoxItem>-->
</ListBox>
隐式创建：
            <ListBox Margin="10" Name="listbox1">
                <StackPanel Orientation="Horizontal">
                    <Image Source="images/06.jpg" Width="20"></Image>
                </StackPanel>
                <StackPanel Orientation="Horizontal">
                    <Label Content="this is a label"/>
                </StackPanel>
                <StackPanel Orientation="Horizontal">
                    <Image Source="images/06.jpg" Width="20"></Image>
                </StackPanel>
            </ListBox>
ComboBox:
用法跟ListBox类似，区别就在于combobox是下拉列表，一次只能选中一项，而listbox可以同时选择多项</p>
<p>PopUp:
冒泡链接
 <Popup Name="poplink" StaysOpen="False" Placement="Mouse">
                    <Border BorderBrush="Silver" BorderThickness="3" Background="White">
                    <TextBlock>for more infomation,see<Hyperlink NavigateUri="www.baidu.com" Click="Hyperlink_Click">百度</Hyperlink>
                    </TextBlock>
                    </Border>
                </Popup></p>
<p>Slider：
滑动条
属性
Maximum="100"   最大值
Minimum="0"         最小值
Value="10"      当前值
Ticks="10,30,50,70"         这样可以设置不均匀刻度
TickPlacement="BottomRight"         刻度位置
TickFrequency="5"               刻度大小
VerticalAlignment="Top"         滑动条相对容器位置
HorizontalAlignment="Left"          相对于容器水平位置
IsSelectionRangeEnabled="True"  SelectionStart="70" SelectionEnd="100"    这样可以把70-100的部分设置为特殊颜色
SmallChange="1" 设置小变化属性，设置后按键盘左右键移动的大小
LargeChange="5" 设置大变化属性，设置后按键盘pageup和pagedown或者鼠标点击滑动条左右移动的大小
IsSnapToTickEnabled="True"          只允许滑块滑动的值为整数
CanContentScroll="True"   按元素滚动 属性
this.scroll.LineDown(); 按行滚动 方法
this.scroll.PageUp();       按页滚动 方法</p>
<p>ProgressBar：
进度条
IsIndeterminate="True"  此属性设置为true时为不断滚动，不确定合适结束
Maximum="100"   最大值
Minimum="0"         最小值
Value="10"      当前值   this.pb.Value+=2;
HorizontalAlignment="Left"      相对于容器水平位置
VerticalAlignment="Top"     滑动条相对容器竖直位置</p>
<p>Calendar:
日历，只能选择日期，不能输入，所以也不可能出现非法日期
DisplayMode="Month" 显示模式， 默认为月，三种。Month，Year，Decade（十年）
DisplayDateStart="2012-5-20"        设置日历的开始日期
DisplayDateEnd="2016-12-12"     设置日历的结束日期
FirstDayOfWeek="Saturday"           设置日历的周几为第一天
this.calendar1.SelectedDate.ToString();   选择的日期
SelectionMode="SingleDate"      选择模式，四种，默认SingleDate单日期、还有SingleRange单范围、MultipleRange多范围、MultipleDate多日期
this.calendar1.SelectedDates[i].ToShortDateString()  选择的日期为SingleRange时候要用集合SelectedDates
IsTodayHighlighted="False"   是否把当前日期高亮显示，默认为true</p>
<p>DatePicker：
日期选择器，可以自己输入日期，所以可能出现非法日期
IsDropDownOpen="True"  打开的时候就显示折叠的日期以供选择，默认为false，即折叠起来
DatePicker_DateValidationError() 事件可以在填写日期错误后报错</p>
<p>11.容器
stackpanel  栈填充，依次填满
dockpanel
grid</p>
<p>Expander:
扩展器
              <Expander Header="expander1">
                    <StackPanel>
                        <Button>按钮1</Button>
                        <Button>按钮2</Button>
                    </StackPanel>
                </Expander>
                <Expander Header="expander2">
                    <TextBlock TextWrapping="Wrap">
                    </TextBlock>
                </Expander>
                <Expander Header="expander3" Height="100">
                    <ScrollViewer VerticalScrollBarVisibility="Auto">
                        <TextBlock TextWrapping="Wrap">
                        </TextBlock>
                    </ScrollViewer>
                </Expander>
            </StackPanel></p>
<p>Tabcontrol：
选项卡
TabStripPlacement="Bottom"  选项卡位置
 this.tabitem1.IsSelected = true;  打开该选项卡
 this.tabcontrol.SelectedIndex = 3; 加载时候默认打开的选项卡
 this.tabcontrol.SelectedIndex = tabcontrol.Items.Count-1;加载时候默认打开最后一个选项卡</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;TabControl</span> <span class="na">TabStripPlacement=</span><span class="s">&quot;Bottom&quot;</span> <span class="na">Name=</span><span class="s">&quot;tabcontrol&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;TabItem</span> <span class="na">Header=</span><span class="s">&quot;grouptitle&quot;</span> <span class="na">Name=</span><span class="s">&quot;tabitem1&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Grid</span> <span class="na">Margin=</span><span class="s">&quot;5&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;GroupBox</span> <span class="na">Margin=</span><span class="s">&quot;5&quot;</span> <span class="na">Header=</span><span class="s">&quot;grouptitle&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;StackPanel&gt;</span>
                    <span class="nt">&lt;RadioButton</span> <span class="na">Margin=</span><span class="s">&quot;3&quot;</span><span class="nt">&gt;</span>单选框1<span class="nt">&lt;/RadioButton&gt;</span>
                    <span class="nt">&lt;RadioButton</span> <span class="na">Margin=</span><span class="s">&quot;3&quot;</span><span class="nt">&gt;</span>单选框2<span class="nt">&lt;/RadioButton&gt;</span>
                    <span class="nt">&lt;RadioButton</span> <span class="na">Margin=</span><span class="s">&quot;3&quot;</span><span class="nt">&gt;</span>单选框3<span class="nt">&lt;/RadioButton&gt;</span>
                    <span class="nt">&lt;Button</span> <span class="na">Margin=</span><span class="s">&quot;3&quot;</span><span class="nt">&gt;</span>保存<span class="nt">&lt;/Button&gt;</span>
                <span class="nt">&lt;/StackPanel&gt;</span>
            <span class="nt">&lt;/GroupBox&gt;</span>
        <span class="nt">&lt;/Grid&gt;</span>
    <span class="nt">&lt;/TabItem&gt;</span>
    <span class="nt">&lt;TabItem&gt;</span>
        <span class="nt">&lt;TabItem.Header&gt;</span>
            <span class="nt">&lt;StackPanel&gt;</span>
                <span class="nt">&lt;TextBlock&gt;</span>设置复杂标题<span class="nt">&lt;/TextBlock&gt;</span>
                <span class="nt">&lt;Button&gt;</span>还有按钮呢<span class="nt">&lt;/Button&gt;</span>
                <span class="nt">&lt;Image</span> <span class="na">Width=</span><span class="s">&quot;20&quot;</span> <span class="na">Source=</span><span class="s">&quot;images/06.jpg&quot;</span><span class="nt">&gt;&lt;/Image&gt;</span>
            <span class="nt">&lt;/StackPanel&gt;</span>
        <span class="nt">&lt;/TabItem.Header&gt;</span>
        <span class="nt">&lt;StackPanel&gt;</span>
            <span class="nt">&lt;CheckBox</span> <span class="na">Margin=</span><span class="s">&quot;3&quot;</span><span class="nt">&gt;</span>复选框1<span class="nt">&lt;/CheckBox&gt;</span>
            <span class="nt">&lt;CheckBox</span> <span class="na">Margin=</span><span class="s">&quot;3&quot;</span><span class="nt">&gt;</span>复选框2<span class="nt">&lt;/CheckBox&gt;</span>
            <span class="nt">&lt;CheckBox</span> <span class="na">Margin=</span><span class="s">&quot;3&quot;</span><span class="nt">&gt;</span>复选框3<span class="nt">&lt;/CheckBox&gt;</span>
            <span class="nt">&lt;Button</span> <span class="na">Click=</span><span class="s">&quot;Button_Click&quot;</span><span class="nt">&gt;</span>转到第一个选项卡<span class="nt">&lt;/Button&gt;</span>
        <span class="nt">&lt;/StackPanel&gt;</span>
    <span class="nt">&lt;/TabItem&gt;</span>
</pre></div>


<p>TextBox 文本框  字符串
RickRextBox  富文本框、高级控件  复杂元素组合
PasswordBox 密码框  字符串</p>
<p>12.Application类（理解）</p>
<p>第一个是用不关闭
第二个是最后一个窗口关闭时候关闭程序
第三个是主窗口关闭时候关闭程序</p>
<div class="highlight"><pre><span></span>public partial class App : Application
{
    //重写注销或关闭系统的方法
    protected override void OnSessionEnding(SessionEndingCancelEventArgs e)
    {
        base.OnSessionEnding(e);
        e.Cancel = true;
        MessageBox.Show(&quot;无法注销或关闭系统&quot;);
    }
</pre></div>


<p>}</p>
<p>12.程序开始界面
鼠标右键单击项目名称，添加图片，然后在图片鼠标右击，更改属性中的生成操作为SplashScreen；则在程序启动时候先加载此图片300ms，然后进入主窗体</p>
<p>Application类任务：
显示初始界面
处理命令行参数
访问当前application对象
在窗口之间进行交互</p>
<p>读取命令行文件
1.鼠标右键单击项目名称，添加文件，这里例子为text.txt，里面写上，this is
a text file；然后修改复制到输出目录属性为始终复制，生成操作为内容；
2.选中项目右键单击
进入属性，调试，命令行参数内容改为文件名text.txt
3.进入app.xaml中删除StartupUri属性，然后鼠标放在application，添加startup事件，然后事件函数内写入：
            MainWindow win = new MainWindow();
            if(e.Args.Length&gt;0)
            {
                string file = e.Args[0];
                if(File.Exists(file))
                {
                    win.LoadFile(file);
                }
            }
            win.Show();
4.MainWindow中写入方法：
        public void LoadFile(string path)
        {
            this.Content = System.IO.File.ReadAllText(path);
            this.Title = path;
        }
5.然后就可以运行了；</p>
<p>13.单实例应用程序
如word，打开很多word文档，任务管理器中只有一个word.exe,此为单实例应用程序
如记事本，打开很多txt文件，任务管理器就有几个记事本.exe，此为多实例应用程序
暂时看不懂，需要时候再深究吧！</p>
<p>14.程序集资源
添加资源（Resource）：程序编译时候会把资源变为二进制嵌入，编译后删除资源文件对可执行程序无影响
内容文件：
1.资源文件很大，嵌入不使用
2.资源文件可选择
3.声音文件不能作为资源
需要做：文件属性改为：生成操作-内容；复制到输出目录：始终复制；
则程序编译时候回在debug里面创建一个内容文件夹，将文件复制进去，程序执行时候读取；</p>
<p>15.将元素绑定到一起binding
绑定表达式；
绑定错误；
绑定模式；
使用代码创建绑定多绑定；
绑定更新；</p>
<p>以下为将文本块字体绑定到滑动条的值：
1.xaml方法：
FontSize="{Binding ElementName=slider1 ,Path=Value,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}
有多种模式，TwoWay为双向，目标修改时候也修改绑定源
第四个绑定参数为绑定更新，可使目标参数被修改时，立即影响源参数
<Slider Name="slider1" Margin="5" TickPlacement="TopLeft" TickFrequency="1" Minimum="1" Maximum="40" Value="10" ></Slider>
            <TextBlock Name="textblock1" FontSize="{Binding ElementName=slider1 ,Path=Value,Mode=TwoWay}" Margin="10">Simple text</TextBlock>
2.代码方法：
            //设置绑定源以及绑定模式
            Binding bingding = new Binding();
            bingding.Source = this.slider1;
            bingding.Path = new PropertyPath("Value");
            bingding.Mode = BindingMode.TwoWay;</p>
<div class="highlight"><pre><span></span>        //设置绑定对象
        this.textblock1.SetBinding(TextBlock.FontSizeProperty,bingding);
</pre></div>


<p>16.绑定非元素对象
1.Source属性
2.RelativeSource属性
3.DateContent属性
Source属性：
在xaml中grid前添加 ：
<Window.Resources>
        <FontFamily x:Key="CustomFont">Calibri</FontFamily>
        <FontFamily x:Key="CustomFont1">Sari</FontFamily>
</Window.Resources>
在xaml中grid内添加：
<TextBlock Name="textblock1" Text="{Binding Source={StaticResource CustomFont1},Path=Source}"></TextBlock>
可实现绑定</p>
<p>下面这句话可实现对系统字体的静态绑定
 <TextBlock Name="textblock1" Text="{Binding Source={x:Static SystemFonts.IconFontFamily},Path=Source}">textblock</TextBlock></p>
<p>RelativeSource属性：
相对路径绑定：Mode：FindAncestor(父类元素)、Self（自身其它对象）、PreviousData（上一个数据）、TemplatedParent"
1.绑定到ancestor：
  <StackPanel Margin="3" Name="stackpanel1">
            <TextBlock Name="textblock1" Text="{Binding Source={x:Static SystemFonts.IconFontFamily},Path=Source}">textblock</TextBlock>
            <TextBlock>
                <TextBlock.Text>
                    <Binding Path="Name">
                        <Binding.RelativeSource>
                            <RelativeSource Mode="FindAncestor" AncestorType="{x:Type StackPanel}">
                            </RelativeSource>
                        </Binding.RelativeSource>
                    </Binding></TextBlock.Text>
            </TextBlock>
        </StackPanel></p>
<p>2.绑定到self：
               <TextBlock.Text>
                    <Binding Path="Margin">
                        <Binding.RelativeSource>
                            <RelativeSource Mode="Self" >
                            </RelativeSource>
                        </Binding.RelativeSource>
                    </Binding></TextBlock.Text>
            </TextBlock></p>
<p>更简洁的方法：使用标记扩展
<TextBlock Margin="5" Text="{Binding Path=Title,RelativeSource={RelativeSource Mode=FindAncestor,AncestorType=Window}}"></TextBlock></p>
<p>添加了AncestorLevel父类层级，由内向外
<TextBlock Margin="5" Text="{Binding Path=Name,RelativeSource={RelativeSource Mode=FindAncestor,AncestorType=StackPanel,AncestorLevel=1}}"></TextBlock></p>
<p>3.DataContext
<TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=Source} "></TextBlock>
<TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=LineSpacing} "></TextBlock>
<TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=FamilyTypefaces[0].Style}"></TextBlock></p>
<p>这种方式比较麻烦，以下更简洁：
程序会从内向外寻找DataContext直到找到不为空的datacontext信息
<StackPanel Margin="3" Name="stackpanel1" DataContext="{x:Static SystemFonts.IconFontFamily}">
<TextBlock Text="{Binding Path=Source}"></TextBlock>
<TextBlock Text="{Binding Path=LineSpacing}"></TextBlock>
<TextBlock Text="{Binding Path=FamilyTypefaces[0].Style}"></TextBlock></StackPanel></p>
<p>16.资源基础
WPF资源
资源集合
资源层次
静态资源和动态资源：
静态资源使用情况：加载时候使用一次，后面资源更改对程序没影响，常用
使用动态资源的情况：资源依赖于系统的设置，动态皮肤，尽可能少用
通过代码访问
应用程序资源
系统资源：
系统字体，系统颜色，系统参数</p>
<p>资源优点：高效，方便维护，适应性好</p>
<p>1.资源的定义与使用
不管何种定义，引用资源顺序为从内到外，同一资源集不能有同名资源
在window中定义
    <Window.Resources>
        <ImageBrush x:Key="TileBrush" TileMode="Tile" ViewportUnits="Absolute" Viewport="0 0 32 32" ImageSource="images/7.png"></ImageBrush>
    </Window.Resources>
    <Grid>
        <StackPanel Margin="3">
            <Button Margin="3" FontSize="14" Padding="5" Background="{StaticResource TileBrush}">A tiled button</Button>
            <Button Margin="3" FontSize="14" Padding="5">0</Button>
            <Button Margin="3" FontSize="14" Padding="5" Background="{DynamicResource TileBrush}">0</Button>
        </StackPanel>
    </Grid>
</Window></p>
<p>或 (在使用之前定义)
        <StackPanel Margin="3">
            <StackPanel.Resources>
                <ImageBrush x:Key="TileBrush" TileMode="Tile" ViewportUnits="Absolute" Viewport="0 0 32 32" ImageSource="images/7.png"></ImageBrush>
            </StackPanel.Resources>
            <Button Margin="3" FontSize="14" Padding="5" Background="{StaticResource TileBrush}">A tiled button</Button>
            <Button Margin="3" FontSize="14" Padding="5">0</Button>
            <Button Margin="3" FontSize="14" Padding="5" Background="{DynamicResource TileBrush}">0</Button>
        </StackPanel></p>
<p>或者在控件内部定义资源
            <Button Margin="3" FontSize="14" Padding="5">
                <Button.Resources>
                    <ImageBrush x:Key="TileBrush" TileMode="Tile" ViewportUnits="Absolute" Viewport="0 0 20 20" ImageSource="images/7.png"></ImageBrush>
                </Button.Resources>
                <Button.Background>
                    <StaticResource ResourceKey="TileBrush"></StaticResource>
                </Button.Background>
            </Button>
还可以把资源定义到app.xaml中：
    <Application.Resources>
            <ImageBrush x:Key="TileBrush" TileMode="Tile" ViewportUnits="Absolute" Viewport="0 0 32 32" ImageSource="images/7.png"></ImageBrush>
</Application.Resources></p>
<p>总之：资源查找顺序是 由内向外，再到应用程序资源，再到程序代码</p>
<p>对系统资源的访问：
<Button Margin="3" FontSize="20" Padding="5" Click="Button_Click" Foreground="{x:Static SystemColors.WindowTextBrush}">change the brush </Button>
上面这句话使加载时候按钮字体颜色跟随系统字体颜色。
下面这句话为动态访问，系统变化，程序立即变化
<Button Margin="3" FontSize="20" Padding="5" Click="Button_Click" Foreground= "{DynamicResource  ResourceKey={x:Static SystemColors.WindowTextBrushKey}}">change the brush </Button></p>
<p>17.样式
18.行为
需要添加这两个引用
Microsoft.Expression.Interactions
System.Windows.Interactivity</p>
<p>19.触发器</p>
<p>20.形状
理解形状
1.可以在任意布局容器中放置形状
2.形状可以用任何通用行为
Fill  填充
Stroke 边框
RadiusX
RadiusY  两个配合来倒角
Stretch  Fill最大限度填充，默认  Uniform均匀填充  UniformToFill最大限度均匀填充 None不显示 </p>
<p>shape类
矩形和椭圆Rectangle   Ellipse
使用viewbox控件缩放形状
直线Line
StrokeThickness 线宽
StrokeStartLineCap 起点形状
StrokeEndLineCap  终点形状
Stroke 线颜色
X1="0" Y1="0" Y2="100" X2="100" 起点终点
折线Polyline
Points="5,5 15,50 50,60 120,10"  设置多个点
多边形Polygon
Points="5,5 15,50 50,60 120,10" 和折线类似，但是会自动闭合，可以使用Fill填充
直线线帽和直线交点
点画线
StrokeDashArray  形状里设置这个属性
StrokeDashArray="1 2" StrokeThickness="5" ，以StrokeThickness为单位画点画线，1为5个单位的实线，2为5*2个单位的虚线；</p>
<p>21.画刷（填充）
SolidColorBrush  实色填充
LinearGradientBrush  线性渐变画刷
Offset为颜色起始点位置，0-1之间
StartPoint EndPoint 为渐变方向坐标，以左上角为0,0，右上角为1,0，左下角为0,1，右下角为1,1，可以在0-1之间
<LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                    <GradientStop Color="Blue" Offset="0"></GradientStop>
                    <GradientStop Color="Red" Offset="0.5"></GradientStop>
                    <GradientStop Color="Green" Offset="0.7"></GradientStop>
                    <GradientStop Color="White" Offset="1"></GradientStop>
</LinearGradientBrush>
RadiaGradientBrush 辐射渐变画刷
 <RadialGradientBrush GradientOrigin="0.7,0.5" RadiusX="1" RadiusY="1">
                    <GradientStop Color="Blue" Offset="0"></GradientStop>
                    <GradientStop Color="White" Offset="0.5"></GradientStop>
                    <GradientStop Color="Blue" Offset="1"> </GradientStop>
 </RadialGradientBrush>
ImageBrush 用图片填充区域
Viewbox="0.4,0.5,0.2,0.2" 可以显示图片中的某部分
TileMode        平铺模式tile平铺 flipx，偶数竖直翻转
<ImageBrush ImageSource="1269.jpg" TileMode="FlipX" ViewportUnits="RelativeToBoundingBox" Viewport="0,0 0.5,0.5"></ImageBrush></p>
<p>VisualBrush 虚拟画刷，原内容改变visual内容也会随着刷新
指复制某个控件的外观给某个控件
<StackPanel>
            <Button Name="cmd" Margin="5">this is a button</Button>
            <Rectangle Height="50" Margin="5" Stroke="Black">
                <Rectangle.Fill>
                    <VisualBrush Visual="{Binding ElementName=cmd}"></VisualBrush>
                </Rectangle.Fill>
            </Rectangle>
</StackPanel></p>
<p>BitmapCacheBrush 位图缓冲画刷
<BitmapCacheBrush Target="{Binding ElementName=cmd}" ></BitmapCacheBrush></p>
<p>22.变换与透明
TranslateTransform
RotateTransform
ScaleTransform
SkewTransform</p>
<p>变换形状
 <Canvas>
        <Rectangle Height="50" Width="100" Canvas.Left="100" Canvas.Top="100" Fill="Yellow" Stroke="Black"></Rectangle>
        <Rectangle Height="50" Width="100" Canvas.Left="100" Canvas.Top="100" Fill="Yellow" Stroke="Black">
            <Rectangle.RenderTransform>
                <RotateTransform Angle="25" CenterX="40" CenterY="25"></RotateTransform>
            </Rectangle.RenderTransform>   //绝对坐标中心
        </Rectangle>
        <Rectangle RenderTransformOrigin="0.5,0.5" Height="50" Width="100" Canvas.Left="100" Canvas.Top="100" Fill="Yellow" Stroke="Black">
            <Rectangle.RenderTransform>  //相对坐标中心
                <RotateTransform Angle="50"></RotateTransform>
            </Rectangle.RenderTransform>
        </Rectangle>
 </Canvas></p>
<p>变换元素
   <StackPanel>
        <StackPanel Margin="25" Background="LightYellow">
            <Button Padding="5" HorizontalAlignment="Left">
                <Button.RenderTransform>
                    <RotateTransform Angle="35" CenterX="45" CenterY="5"></RotateTransform>
                </Button.RenderTransform>
                <Button.Content>I,m rotate 35 degrees</Button.Content>
            </Button>
            <Button Padding="5" HorizontalAlignment="Left">I,m not</Button>
        </StackPanel>
        <StackPanel Margin="25" Background="LightYellow">
            <Button Padding="5" HorizontalAlignment="Left">
                <Button.LayoutTransform>
                    <RotateTransform Angle="35" CenterX="45" CenterY="5"></RotateTransform>
                </Button.LayoutTransform>
                <Button.Content>I,m rotate 35 degrees</Button.Content>
            </Button>
            <Button Padding="5" HorizontalAlignment="Left">I,m not</Button>
        </StackPanel>
</StackPanel></p>
<p>使用元素半透明
opcity  0-1</p>
<p>透明掩码
  <Window.Background>
        <ImageBrush ImageSource="1269.jpg"></ImageBrush>
    </Window.Background>
    <Grid Margin="10,50">
        <Button Background="Purple" FontSize="14" FontWeight="Bold">
            <Button.OpacityMask>
                <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                    <GradientStop Offset="0" Color="Black"></GradientStop>
                    <GradientStop Offset="1" Color="Transparent"></GradientStop>
                </LinearGradientBrush>
            </Button.OpacityMask>
            <Button.Content>A partially transparent button</Button.Content>
        </Button>
</Grid></p>
<p><Grid Margin="10" Grid.IsSharedSizeScope="True" VerticalAlignment="Center">
        <Grid.RowDefinitions>
            <RowDefinition Height="auto" SharedSizeGroup="Row"></RowDefinition>
            <RowDefinition SharedSizeGroup="Row"></RowDefinition>
        </Grid.RowDefinitions>
        <TextBlock Name="textblock1" FontSize="30">this is a reflected textblock.</TextBlock>
        <Rectangle Grid.Row="1" RenderTransformOrigin="1,0.5">
            <Rectangle.Fill>
                <VisualBrush Visual="{Binding ElementName=textblock1}"></VisualBrush>
            </Rectangle.Fill>
            <Rectangle.OpacityMask>
                <LinearGradientBrush StartPoint="0,0" EndPoint="0,1" >
                    <GradientStop Color="Transparent" Offset="0.3"></GradientStop>
                    <GradientStop Color="#44000000" Offset="1"></GradientStop>
                </LinearGradientBrush>
            </Rectangle.OpacityMask>
            <Rectangle.RenderTransform>
                <ScaleTransform ScaleY="-1"></ScaleTransform>
            </Rectangle.RenderTransform>
        </Rectangle>
    </Grid></p>
<p>23.路径与几何图形</p>
<p>1.直线，矩形和椭圆图形：
使用此种方法定义各种图形，在同一路径中组合多种图形时可选用此方法
<Path Fill="Yellow" Stroke="Blue" Grid.Row="1" Margin="10">
            <Path.Data>
                <!--<RectangleGeometry Rect="100,0 100,50"></RectangleGeometry>-->
                <!--<LineGeometry StartPoint="0,0" EndPoint="100,200"></LineGeometry>-->
                <EllipseGeometry Center="100,100" RadiusX="100" RadiusY="50"></EllipseGeometry>
            </Path.Data>
</Path>
2.使用GeometryGroup组合形状：（对于大量图形绘制效率较高）
  <Path Fill="Yellow" Stroke="Blue" Grid.Row="1" Margin="10">
            <Path.Data>
                <GeometryGroup>
                    <EllipseGeometry Center="100,100" RadiusX="100" RadiusY="50"></EllipseGeometry>
                    <RectangleGeometry Rect="100,0 100,50"></RectangleGeometry>
                    <LineGeometry StartPoint="0,0" EndPoint="100,200"></LineGeometry>
                </GeometryGroup>
            </Path.Data>
        </Path></p>
<p>使用重复图形时，可以把图形定义在Windows资源中，效果跟上图一样；
 <Window.Resources>
        <GeometryGroup x:Key="geometrygroup">
            <EllipseGeometry Center="100,100" RadiusX="100" RadiusY="50"></EllipseGeometry>
            <RectangleGeometry Rect="100,0 100,50"></RectangleGeometry>
            <LineGeometry StartPoint="0,0" EndPoint="100,200"></LineGeometry>
        </GeometryGroup>
</Window.Resources>
.............
        <Path Fill="Yellow" Stroke="Blue" Grid.Row="1" Margin="10" Data="{StaticResource geometrygroup}"></Path></p>
<p>可以使用图形遮挡显示文字，关键：GeometryGroup 中FillRule属性设置为EvenOld，则交叠处为透明，Nonzero则不透明；
 <Window.Resources>
        <GeometryGroup x:Key="geometrygroup" FillRule="EvenOdd">
            <EllipseGeometry Center="60,35" RadiusX="100" RadiusY="50"></EllipseGeometry>
            <RectangleGeometry Rect="0,0 120,70"></RectangleGeometry>
        </GeometryGroup>
    </Window.Resources>
    <Canvas Margin="5">
        <TextBlock Canvas.Top="20" Canvas.Left="50" FontSize="25" FontWeight="Bold">hello world!</TextBlock>
        <Path Fill="Yellow" Stroke="Blue" Canvas.Top="10" Canvas.Left="50" Grid.Row="1" Margin="10" Data="{StaticResource geometrygroup}"></Path>
    </Canvas></p>
<p>3.使用CombinedGeometry融合几何形状
关键：属性GeometryCombineMode指示了相交模式：Exclude、Intersect、Union、Xor，交集补集等
 <CombinedGeometry x:Key="combinedgeometry" GeometryCombineMode="Exclude">
            <CombinedGeometry.Geometry1>
                <EllipseGeometry Center="60,35" RadiusX="100" RadiusY="50"></EllipseGeometry>
            </CombinedGeometry.Geometry1>
            <CombinedGeometry.Geometry2>
                <RectangleGeometry Rect="0,0 120,70"></RectangleGeometry>
            </CombinedGeometry.Geometry2>
        </CombinedGeometry>
</Window.Resources>
..........
 <Canvas Margin="5">
        <TextBlock Canvas.Top="20" Canvas.Left="50" FontSize="25" FontWeight="Bold">hello world!</TextBlock>
        <Path Fill="Yellow" Stroke="Blue" Canvas.Top="10" Canvas.Left="50" Grid.Row="1" Margin="10" Data="{StaticResource combinedgeometry}"></Path>
    </Canvas>
效果同2.</p>
<p>4.使用PathGeometry绘制曲线和直线
1.直线
IsClosed 指示是否自动封闭
 <Path Fill="Yellow" Stroke="Blue" Canvas.Top="10" Canvas.Left="50" Grid.Row="1" Margin="10" >
            <Path.Data>
                <PathGeometry>
                    <PathFigure StartPoint="0,0" IsClosed="True" >
                        <LineSegment Point="100,100"></LineSegment>
                        <LineSegment Point="100,50"></LineSegment>
                        <LineSegment Point="180,0"></LineSegment>
                    </PathFigure>
                </PathGeometry>
            </Path.Data></p>
<p>2.曲线
关键：IsClosed指示是否封闭，IsFilled指示是否填充，IsLargeArc指示从大弧度还是小弧度绘制
  <Path Fill="Yellow" Stroke="Blue" Canvas.Top="10" Canvas.Left="150" Grid.Row="1" Margin="10" >
            <Path.Data>
                <PathGeometry>
                    <PathFigure StartPoint="0,0" IsClosed="False" IsFilled="False">
                        <ArcSegment Point="60,100" Size="100,200" IsLargeArc="True"></ArcSegment>
                    </PathFigure>
                </PathGeometry>
            </Path.Data>
        </Path>
最终效果：</p>
<p>贝塞尔曲线：
StartPoint为起始点，Point1、Point2为控制点，Point3为终点
 <PathFigure StartPoint="0,0" IsClosed="False" IsFilled="False">
                        <BezierSegment Point1="130,30" Point2="40,140" Point3="150,150"></BezierSegment>
                    </PathFigure></p>
<p>5.微语言几何图形
可以使用较少的代码创建图形，缺点是修改不方便
<Path Fill="Yellow" Stroke="Blue" Canvas.Top="10" Canvas.Left="150" Grid.Row="1" Margin="10" Data="M10,100 L100,100 L200,50 Z"></p>
<p>6.使用几何图形进行裁剪
   <Window.Resources>
        <GeometryGroup x:Key="geometrygroup" FillRule="Nonzero">
            <EllipseGeometry Center="100,60" RadiusX="50" RadiusY="50"></EllipseGeometry>
            <EllipseGeometry Center="120,160" RadiusX="50" RadiusY="100"></EllipseGeometry>
        </GeometryGroup>
    </Window.Resources>
    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition></ColumnDefinition>
            <ColumnDefinition></ColumnDefinition>
        </Grid.ColumnDefinitions>
        <Button Clip="{StaticResource geometrygroup}">a button</Button>
        <Image Stretch="Fill" HorizontalAlignment="Right" Grid.Column="1" Source="6033.jpg" Clip="{StaticResource geometrygroup}"></Image>
</Grid></p>
<p>24.可视化对象
更轻量级对象，在大量绘图中实用
DrawingVisual Visual=new DrawingVisual();
DrawingContext dc=Visual.RenderOpen();
dc.DrawLine()  //画直线
dc.DrawRectangle();  //画矩形
dc.DrawRoundRectangle();  //画矩形
dc.DrawEllipse();   //绘制椭圆
dc.DrawGeometry();  //绘制几何图像
dc.DrawText();      //画矩形文本
dc.DrawImage(); //画位图图像
dc.DrawVedio(); //画视频对象
dc.Close();   //关闭
绘制可视化对象
在元素中包装可视化对象</p>
<p>25.效果
BlurEffect类  模糊效果，Radius="2"，设置默认模糊值，默认值5
  <Button Padding="5" Margin="3" Content="Blurred radius=2">
            <Button.Effect>
                <BlurEffect Radius="2"></BlurEffect>
            </Button.Effect>
        </Button>
        <Button Padding="5" Margin="3" Content="Blurred  radius=5">
            <Button.Effect>
                <BlurEffect Radius="5"></BlurEffect>
            </Button.Effect>
        </Button>
        <Button Padding="5" Margin="3" Content="Blurred  radius=8">
            <Button.Effect>
                <BlurEffect Radius="8"></BlurEffect>
            </Button.Effect>
        </Button></p>
<p>DropShadowEffect类 偏移阴影
ShadowDepth 阴影高度
BlurRadius 模糊半径
Direction 阴影方向
Color 阴影颜色
Opacity 阴影透明度</p>
<p><StackPanel >
        <TextBlock FontSize="20" Margin="5" Text="Basic dropshadow effect">
            <TextBlock.Effect>
                <DropShadowEffect></DropShadowEffect>
            </TextBlock.Effect>
        </TextBlock>
        <TextBlock FontSize="20" Margin="5" Text="blue dropshadow">
            <TextBlock.Effect>
                <DropShadowEffect Color="Blue"></DropShadowEffect>
            </TextBlock.Effect>
        </TextBlock>
        <TextBlock FontSize="20" Margin="5" Text="blurred dropshadow">
            <TextBlock.Effect>
                <DropShadowEffect BlurRadius="15"></DropShadowEffect>
            </TextBlock.Effect>
        </TextBlock>
        <TextBlock FontSize="20" Margin="5" Text="dropshadowdepth">
            <TextBlock.Effect>
                <DropShadowEffect ShadowDepth="20"></DropShadowEffect>
            </TextBlock.Effect>
        </TextBlock>
        <TextBlock FontSize="20" Margin="5" Text="transparent opcity">
            <TextBlock.Effect>
                <DropShadowEffect ShadowDepth="20" Opacity="0.5"></DropShadowEffect>
            </TextBlock.Effect>
        </TextBlock>
        <TextBlock FontSize="20" Margin="5" Text="transparent opcity">
            <TextBlock.Effect>
                <DropShadowEffect ShadowDepth="20" Opacity="0.2" Direction="90"></DropShadowEffect>
            </TextBlock.Effect>
        </TextBlock>
</StackPanel></p>
<p>ShaderEffect 类
网上查找例子</p>
<p>26.WriteableBitmap类
可写位图类，继承于BitmapSource类</p>
<p>生成位图
写入WriteableBitmap对象
更高效的像素写入</p>
<p>WriteableBitmap wb=new WriteableBitmap((int)this.ActualWidth,(int)this.ActualHeight,96,96,PixelFromats.Bgra32);</p>
<p>WritePixels();</p>
<p>byte blue=100;
byte green=50;
byte red=50;
byte alpha=255;
byte[] colorData={blue,green,red,alpha};</p>
<p>Int32Rect rect=new Int32Rect(0,0,100,50);</p>
<p>wb.WritePixels(rect,colorData,4,0);</p>
<p>27.基本动画
理解WPF动画
Animation类
使用代码创建动画
同时发生的动画
动画的生命周期</p>
<p>private void button1_Click(object sender, RoutedEventArgs e)
        {
            DoubleAnimation widthAnimation = new DoubleAnimation();
            widthAnimation.To = this.Width - 30;
            widthAnimation.From = 150;
            widthAnimation.Duration = TimeSpan.FromSeconds(2);
            //widthAnimation.AutoReverse = true;  //反向回到初始宽度
            //widthAnimation.FillBehavior = FillBehavior.Stop; //动画结束后直接跳到初始宽度
            widthAnimation.Completed += animation_Completed;
            button1.BeginAnimation(Button.WidthProperty, widthAnimation);
            //this.button1.width=250; //widthAnimation.To删除时本句话有效，否则动画会忽略本句代码</p>
<div class="highlight"><pre><span></span>        DoubleAnimation heightthAnimation = new DoubleAnimation();
        heightthAnimation.To = this.Height - 30;
        heightthAnimation.From = 40;
        heightthAnimation.Duration = TimeSpan.FromSeconds(2);
        button1.BeginAnimation(Button.HeightProperty, heightthAnimation);
    }
    private void animation_Completed(object sender, EventArgs e)
    {
        button1.BeginAnimation(Button.WidthProperty, null);
        button1.Width = 250;
    }
</pre></div>


<p>28.TimeLine类
using System.Windows.Media.Animation;//动画效果</p>
<p>Timeline类的属性
AccelerationRatio属性和DecelerationRatio属性
RepeatBehavior属性
       private void Button_Click(object sender, RoutedEventArgs e)
        {
            DoubleAnimation dAnimation = new DoubleAnimation();
            dAnimation.From = 50;
            dAnimation.To = this.Height / 2;
            //dAnimation.BeginTime = TimeSpan.FromSeconds(3);//延时
            dAnimation.Duration = TimeSpan.FromSeconds(10); //动画持续时间
            dAnimation.SpeedRatio = 2;      //动画速度 time=持续时间/speedratio
            dAnimation.AutoReverse = true; //动画返回
            dAnimation.AccelerationRatio = 0.3; //加速 前一部分time=持续时间*AccelerationRatio
            dAnimation.DecelerationRatio = 0.3; //减速 后一部分
            dAnimation.RepeatBehavior = new RepeatBehavior(2);  //动画重复次数
            this.ellipse1.BeginAnimation(Ellipse.WidthProperty, dAnimation);
            this.ellipse1.BeginAnimation(Ellipse.HeightProperty, dAnimation);
        }</p>
<p>29.故事板
<Storyboard TargetName=”cmdGrow”TargetProperty=”Width”>
<DoubleAnimation From=”160” To=”300” Duration=”0:0:5”/></Storyboard> </p>
<p>故事板
事件触发器
<Button Width="200" Name="cmdGrow">
                <Button.Content>this is a button</Button.Content>
                <Button.Triggers>
                    <EventTrigger RoutedEvent="Button.Click">
                        <EventTrigger.Actions>
                            <BeginStoryboard>
                                <Storyboard TargetName="cmdGrow" TargetProperty="Width">
                                    <DoubleAnimation From="160" To="300" Duration="0:0:5"></DoubleAnimation>
                                    </Storyboard>
                            </BeginStoryboard>
                        </EventTrigger.Actions></p>
<div class="highlight"><pre><span></span>                <span class="nt">&lt;/EventTrigger&gt;</span>
            <span class="nt">&lt;/Button.Triggers&gt;</span>
        <span class="nt">&lt;/Button&gt;</span>
</pre></div>


<p>使用样式关联触发器
  <Window.Resources>
        <Style x:Key="GrowButtonStyle">
            <Style.Triggers>
                <Trigger Property="Button.IsPressed" Value="true">
                    <Trigger.EnterActions>
                        <BeginStoryboard>
                            <Storyboard>
                                <DoubleAnimation From="160" To="300" Duration="0:0:5" Storyboard.TargetProperty="Width"></DoubleAnimation>
                            </Storyboard>
                        </BeginStoryboard>
                    </Trigger.EnterActions>
                </Trigger>
            </Style.Triggers>
        </Style>
</Window.Resources>
.....
    <Button Width="200" Name="cmdGrow" Style="{StaticResource GrowButtonStyle}">
                <Button.Content>this is a button</Button.Content> </Button>
同步的动画
两个动画，
FillBehavior stop时第一个动画结束回到最初再执行第二个动画
FillBehavior HoldEnd 时第一个动画结束时保持继续第二个动画
  <Storyboard>
<DoubleAnimation From="160" To="300" Duration="0:0:5" Storyboard.TargetProperty="Width"> </DoubleAnimation>
<DoubleAnimation From="160" To="300" Duration="0:0:3" Storyboard.TargetProperty="Height" FillBehavior="Stop"></DoubleAnimation></Storyboard></p>
<p>30.控制播放
PauseStoryboard 暂停
ResumeStoryboard 恢复
StopStoryboard 停止（恢复到开始点）
SeekStoryboard  到指定位置
SetStoryboardSpeedRatio 设置故事板运行速度
SkipStoryboardToFill  <br>
RemoveStoryboard  移除故事板</p>
<p>控制故事板的动作类
控制播放
监视动画进度
具体见项目：wpf  控制故事板播放</p>
<p>31.动画缓动
作用：改进动画效果，更加自然，比关键帧动画操作少
具体见项目：wpf 故事板动画
使用缓动函数 DoubleAnimation.EasingFunction
在动画开始时候应用缓动与在动画结束时应用缓动
EasingMode 缓动模式
<DoubleAnimation.EasingFunction><ElasticEase EasingMode="EaseOut" Oscillations="10"> </ElasticEase></DoubleAnimation.EasingFunction></DoubleAnimation>
缓动函数类
BounceEase 不会超过设定的幅度
ElasticEase  可能超过设定的幅度
CircleEase
BackEase
CubicEase
SineEase 正弦函数加速减速
PowerEase 幂函数</p>
<p>创建自定义缓动函数</p>
<p>32.动画性能
见：wpf 动画性能
调整帧速率：
动画不需要很高的帧速率，默认为60
位图缓存：
控件的属性中+CacheMode="BitmapCache"，但是出现类型转换错误，还不知道原因
需要大量重新绘制合适、内容经常变换则不合适、尽可能降低内容数量</p>
<p>33.动态变换
见：wpf 动态变换变换方式：
RenderTransform(渲染变换)属性：布局以后再变换
LayoutTransform(布局变换)属性：变换前先布局，效率不高
动态变换
动态改变多个变换</p>
<p>34.动态改变画刷
ColorAnimation
PointAnimation</p>
<p>VisualBrush画刷
SkewTransform倾斜
RotateTransform旋转</p>
<p>具体见：wpf 动态改变画刷</p>
<p>35.动态改变像素着色器
具体见：wpf 动态改变像素着色器</p>
<p>36.关键帧动画
PointAnimationUsingKeyFrames
线性关键帧动画 LinearPointKeyFrame 线性平滑改变
离散的关键帧动画 DiscretePointKeyFrame 跳跃性改变
缓动关键帧  EasingPointKeyFrame 缓缓改变 +EasingPointKeyFrame.EasingFunction
样条关键帧动画（开始结束有加速过程，看起来更自然） DoubleAnimationUsingKeyFrames--&gt;SplineDoubleKeyFrame</p>
<p>37.基于路径的动画
具体见：wpf 基于路径的动画</p>
<p>38.基于帧的动画
具体见：wpf 基于帧的动画
CompositionTarget.Redering 事件</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="http://www.cqu.edu.cn/">重庆大学</a></li>
                            <li><a href="http://www.ustc.edu.cn/">中国科学技术大学</a></li>
                            <li><a href="http://www.snst.ustc.edu.cn/">中国科大核科学技术学院</a></li>
                            <li><a href="http://crmp.ustc.edu.cn/">中国科大放射医学物理中心</a></li>
                        </ul>
                </div><!-- /.blogroll -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>